my name is dean

4byte
   1       8       23 bti = float
부호 지수부 가수부
예) 12.34*10^2 , 12.34 = 가수부, 2= 지수부

함수를 구분하는 정확한 기준은 시그니쳐(프로토타입이 아님)

재귀함수 : 자기 자신을 호출하는 함수, 문제를 부분으로 나누어 큰 문제를 해결하기 위해서 사용, for문으로 대체 가능

가변인자 함수 : printf()와 같이 인자의 수가 일정하지 않다.

보수란? '+'밖에 안되는 환경에서 '+'를 통해 '-'를 하기 위한 것. (Carry발생으로 가능함)
보수는 시스템에 따라서 선택, 언어에 따라 선택되는게 아님
1의 보수는 중,대형 시스템에서 사용
결과의 MSB = 1이면 음수/ MSB = 0이면 양수

엔디안(Endian)
리틀 엔디안과 빅엔디안
데이터를 저장하는 방법의 차이
리틀엔디안 : x86 / 빅엔디안 : RISC 및 모토로라 기종

리틀 엔디안 
10 = 0000 1010 -> 1010 0000
빅 엔디안
10 = 0000 1010

리틀 엔디안의 장점
- 산술 순서(오른쪽->왼쪽)과 같기 때문에 프로세서에서 산술 연산의 수행이 더 쉬워진다
- 사이즈가 32비트인 정수를 16비트 정수로 변환할 때 처럼 사이즈가 큰 정수를 사이즈가 작은 정수로 변환해야 할 때 특별한 조작을 가하지 않고도 작은 자리의 자릿수로 읽을 수 있다.

빅 엔디안 장점
- 보기 쉽다.
- 네트워크 표준 프로토콜
- 정수로 정렬된 큰 수에 대한 비교를 메모리의 작은 주소로부터 큰 주소 방향으로 읽으면서 바로 비교할 수 있다.


포인터
메모리의 주소를 가지고 있는 변수
변수명 앞에 &를 붙이면 해당 변수의 주소를 얻을 수 포있다.

*: asterisk. 포인터가 실제 가르키는 값

char arr[10] = "char arr"; //나머지 부분은 0으로 초기화 됨
상수를 변수에 넣을 수는 있지만, 상수를 상수에 넣을 수는 없다.
배열명 : 상수, 포인터 : 변수


Pointer and const prefix
point에서 const는 *수 만큼 붙일 수 있다.

const char *a = (char*)0x1000;
char * const a = (char*)0x1000;
const char* const a = (char*)0x1000;

함수이름이 포인터, 즉 주소
printf("0x%p\n", main);


함수 포인터 
만드는법
1. 변수명 생성 : p_func
2. 포인터임을 알린다 : (*p_func)
3. 함수의 인자형을 쓴다 : (*p_func)(int, int)
4. 함수의 리턴형을 쓴다 : int(*p_func)(int, int)

int (*p_func)(int, int) : 인자 intx2, 리턴 int

함수포인터 사용 이유 : 인터페이스를 제공하기 위해서

struct device{
	char *name;
	int size;
	void (*initialization)(struct device *, char *name);
	void (*run)();
	void (*terminate)();
};
하나의 OS가 있고, 위와 같은 구조체를 제공
구조체 선언 후, 해당 디바이스를 초기화, 실행, 종료루틴을 등록하면 각 디바이스 마다 초기화, 실행, 종료를 한다고 하자
각각 다른 디바이스지만 각각 다른 함수들이 한번에 호출된다.

my_device[0].initialization = CPU_initialization;
my_device[1].initlaization = RAM_initalization;

for(int i = 0; i<2; i++)
my_device[i].initialization(&my_device, name[i]);

trace가 힘들다, 함수의 내용을 숨길 수 있음


구조체 멤버 접근
객체(Object) : . Operator
객체 포인터 : -> Operator

Byte Alignment

struct test{
	int num; //4byte
	char name; //1byte
	float data; //4byte
};
-> 12 byte
구조체 멤버중 가장 큰 크기를 찾음, 그 단위로 메모리를 잡음.
넘치지 않을 만큼 채움

struct test{
	char num; //1byte
	char name; //1byte
	double data; //8byte
};
-> 16 byte

struct test{
	char num; //1byte
	double name; //8byte
	char data; //1byte
};
-> 24 byte

performance에 관한 관점에서 바라보면 용량은 문제가 되지 않는다.
코드상에서 어떤 것을 더 많이 사용하냐에 따라서 배치하는 것도 아키텍쳐적인 문제


매크로
#define의 활용
: - 컴파일 타임에 define 내용으로 대처
 - 사용하는 경우가 많은 경우에 좋음.
 - 전역변수와는 다르게 공간을 차지 하지 않음.

macro는 하나의 라인에 모두 작성해줘야 한다.
하지만 다중 라인을 하나의 라인으로 인식해주기 위해 "\"를 사용할 수 있다.
#define MACRO do{ \
	printf("first"); \
	printf("second"); \
}while(0);


#define MACRO(X) #x

void main(){
	int hello_world;
	printf("%s\n", MACRO(hello_world));
}
#을 붙여주면 string 형태로 바뀜


printf("%d %c\n"); -> 0과 공백이 출력됨
printf("abcd""efgh\n"); -> 문자열 두개가 연속해서 나옴
a = printf("12345\n") -> printf의 리턴형은 출력된 문자열의 갯수이다.


#define MACRO(x,y) x##_##y 
 : ##은 들어온 인자들을 모두 합쳐줌

void main(){
	int a_1 = 10;

	printf("%d\n", MACRO(a,1));
	//->a_1의 10이 출력됨.
} 


#if의 활용

#define SMALL 10
#define LARGE 40
#define SIZE SMALL

int main()
{
#if (SIZE ==SMALL)
	int list[SMALL];
#elif(SIZE == LARGE)
	int list[LARGE];
#endif
}


--------------------------

#define SIZE 10

int main()
{
#ifdef SIZE
printf("Size is defined\n");
#else
printf("Size is not defined\n");
}

함수와 매크로의 차이점
매크로 : 코드사이즈 쓸수록 많아짐 실행속도는 빠름
함수 : 코드사이즈는 호출문만 증가하고 실행속도는 느림

static prefix
- static의 의미? 
 : 프로그램 시작부터 종료까지 존재하는 변수(전역변수처럼 사용됨)

- 전역변수에서의 static의 의미?
 : 외부참조 불가(같은 소스파일에 있는 영역에서만 호출 할 수 있음)

- 함수에서의 static의 의미?
 : 변수에 static을 사용하는 의미와 동일

inline function
- 매크로는 preprocessor가 처리, 인라인은 compiler가 처리

__inline int some_function(int a){
	if(a==0) return 1;
	else if( a==1) return 3;
	else return a*2;
}